Docker Day - 1
Comands:
1  curl -fsSL https://get.docker.com -o install-docker.sh
    2  ls
    3  sh install-docker.sh
    4  docker --version
    5  docker ps
    6  docker ps -a
    7  docker images
    8  docker run hello-world
    9  docker ps
   10  docker ps -a
   11  docker images
   12  docker run -it ubuntu
   13  docker ps
   14  docker ps -a
   15  docker start 8aafca4a6f92
   16  docker ps
   17  docker exec -it 8aafca4a6f92 bin/bash
   18  docker ps
   19  docker images
   20  docker commit 8aafca4a6f92 anuragiswrongimage
   21  docker images
   22  docker pull nginx
   23  docker images
   24  docker run nginx
   25  docker ps
   26  docker ps -a
   27  docker run -p 80:80 nginx
   28  docker run --name docker-nginx -p 80:80 nginx
   29  docker ps -a
   30  docker run --name -d docker-nginx -p 80:80 nginx
   31  docker run --name docker-nginx -d -p 80:80 nginx
   32  docker run --name docker-nginx1 -d -p 80:80 nginx
   12 docker exec -it container_id /bin/bash
Main Topic: Introduction to Docker and Containerization
The session was a Day 1 introduction to Docker for Batch-42, focusing on understanding the fundamental problems that Docker solves before diving into the tool itself.
Key Concepts Covered:
Problem Statement: The instructor explained why Docker was created by comparing it to assembling a mobile phone - if parts are assembled separately in production, things don't work properly. Similarly, applications need all dependencies packaged together.
Virtualization vs Containerization:
Virtual Machines require heavy hardware, hypervisor layers, and full operating systems
VMs are large in size (2GB+) making them difficult to move between environments
Docker containers are much lighter (around 72MB for Ubuntu base image vs 2GB+ for VMs)
Microservices Architecture: Discussion on how Docker enables microservices where large applications are divided into small, independent services that can work separately.
Docker Basics:
Image: Package of binaries, libraries, and dependencies with OS in one box
Container: Running instance of an image
Node: VM with application installed
Practical Exercise:
Students created Ubuntu machines on Google Cloud
Installed Docker using automated commands
Pulled Jenkins image from Docker Hub (491MB size)
Ran Jenkins container using docker run command with port mapping
Homework Assigned:
Download guest operating system
Find command to delete VM from command line
Practice the Docker installation and Jenkins container deployment
The session emphasized understanding problems before learning solutions, with focus on hands-on practice.
===============================================================================================================
Based on the meeting transcript, the session was heavily focused on scenario-based learning and practical Q&A throughout. Here are the key scenario-based topics covered:
Real-world Problem Scenarios: The instructor explained why Docker was created by discussing real-world problems with virtual machines - heavy size, difficult transportation between environments, and assembly issues in production.
Practical Deployment Scenarios: The session covered scenarios like moving applications from Dev to QA to Production environments, explaining how Docker solves the problem of "it works on my machine but not in production."
Microservices Architecture Scenarios: Discussion included real-world examples like Flipkart's Big Billion Sale, where different services (order service, cart, user management) need to scale independently.
Jenkins Installation Scenario: A practical scenario was demonstrated where installing Jenkins requires 7 steps in a VM, and how one missing step causes failure. Docker solves this by packaging everything together.
Interview-focused Questions: The instructor asked scenario-based questions like:
What CPU/memory configurations are used in real-time production (Answer: 16 CPUs, 32GB RAM as standard)
How to handle different OS flavors (Ubuntu, CentOS) for the same application
Port mapping and container networking scenarios
The instructor emphasized learning through practical scenarios rather than just theory, encouraging students to solve real problems and share screenshots of their implementations in the WhatsApp group.
================================================================================================================================


The instructor emphasized understanding problems before learning tools, and stressed that students should be able to explain these concepts clearly for interviews.
=================================================================================================================
To install the latest stable versions of Docker CLI, Docker Engine, and their
# dependencies:
#
# 1. download the script
#
#   $ curl -fsSL https://get.docker.com -o install-docker.sh
#
# 2. verify the script's content
#
#   $ cat install-docker.sh
#
# 3. run the script with --dry-run to verify the steps it executes
#
#   $ sh install-docker.sh --dry-run
#
# 4. run the script either as root, or using sudo to perform the installation.
#
#   $ sudo sh install-docker.sh
======================================================================================================================
Step 1 â€“ Pull ubuntu image from docker hub
docker images
Step 2  - Run the image in interactive mode to make a container
	docker run -it ubuntu     
Step 3 Come out from the container with exit command 
Step 4 â€“ Start a container 
	docker start <container ID>
Step -5  logged into the bash of the  container 
	docker exec -it 8aafca4a6f92 bin/bash
Step -6  Your container is ready to play any application try to install GIT in ubuntu container
apt update 	
apt install git-all 
apt install ansible
apt install python
it is use for make container to image
docker commit <container_id> <image_name>:<tag>

===========================================================================================================================================================

Docker day 2
Based on the meeting transcript, here is a summary:

This was a training session on Docker and Kubernetes led by Vikas (Cloud DevOps Hub) as part of Batch-42. The session covered:

Main Topics:

Docker Basics: The instructor explained Docker as an open-source containerization platform that helps build, ship, and run applications in containerized form across different environments.

Docker Architecture: Three main components were discussed:

Client (where commands are executed)
Host (where Docker is installed)
Registry (Docker Hub - where images are stored)
Docker Workflow: When running "docker run hello-world":

Docker client connects to Docker daemon
Docker daemon checks for image locally
If not found, pulls image from Docker Hub
Creates container from image
Runs the container and displays output
Practical Commands Covered:

docker pull (downloads image only)
docker run (downloads and runs container)
docker ps (shows running containers)
docker ps -a (shows all containers including stopped ones)
docker images (lists available images)
docker start (starts stopped container)
docker exec -it (enters running container)
docker commit (converts container to image)
docker run -it -d -p 8080:8080 jenkins/jenkins:latest
cat /var/jenkins_home/secrets/initialAdminPassword
docker ps
docker exec -it b1f980c2a1f2 bin/bash
Port mapping using -p flag
Naming containers using --name flag
Hands-on Practice: Students created VMs on Google Cloud, installed Docker using scripted approach, worked with Ubuntu and Nginx containers, installed packages inside containers, and practiced port mapping.

Key Concepts: Container lifecycle, interactive mode (-it flag), detached mode (-d flag), Docker Hub registry (public vs private images), and difference between docker run and docker pull commands.
=========================================================================================================


Day 3:

Based on the meeting transcript, here is a summary:

This was Day 3 of a Docker training session led by Vikas from CloudDevOpsHub for Batch 42, focusing on Multi-Cloud with AWS, DevOps, and AI.

Key Topics Covered:

Docker Installation: Students learned to install Docker using scripted methods on Google Cloud VMs, with commands like "sudo apt-get update && sudo apt install docker.io -y"

Container Operations:

Running containers with different flags (IT, D for interactive and detached modes)
Port mapping using hyphen P (e.g., 80:80)
Container naming using --name flag
Starting, stopping, and removing containers
Volume Mapping: Students learned to map local files to containers using hyphen V flag, creating custom web pages by mapping local HTML files to NGINX containers at /usr/share/nginx/html location

Practical Exercises:

Running NGINX containers with custom HTML pages
Using ChatGPT to generate HTML code for custom landing pages
Installing and unlocking Jenkins in containers
Accessing Jenkins admin password using "docker exec -it /bin/bash"
Interview-Focused Concepts:

Container startup time measurement using "time" command
Alpine Linux as lightweight image (3-8 MB size, production-ready)
Checking container CPU/memory usage with "docker stats" command
Running multiple containers on single VM using loops
Assignments: Students were given assignments to install Docker via scripted way and pull Ubuntu, NGINX, and CentOS images, with submissions tracked through Google Classroom.

=======================================================================================
Day 4:
Docker file:

FROM ubuntu    ----> os image
MAINTAINER clouddevopshub@gmail.com  ---> optional for owner name
RUN apt-get update                   --->> any os level command
RUN apt-get install nginx -y           ---->>> any os level command   
CMD ["echo","Image created"]              ------>>> any application lavel command

docker login
docker tag 5e92a79a891c vikas4cloud/shilpa42:latest
docker tag <image-id of mynginxbatch17 > vikas4cloud/mynginxbatch21:latest
docker push asamanta03/mynginx42(image name)
docker pull asamanta03/mynginx42(image name)

entry point:
this is the 1st command to be run as soon as container is ready.
======================================================================================================
This meeting covered Docker and Dockerfile concepts with hands-on practice. Here's a summary:

Main Topics:

Docker Installation Methods:

Docker Desktop installation on Windows (local machine)
Installing Docker on cloud VMs (Google Cloud/AWS)
Kubernetes cluster setup alongside Docker
System requirements: virtualization enabled, WSL installation, adequate RAM (12GB+ recommended)
Dockerfile Fundamentals:

Dockerfile is a text document with no extension containing commands to build images
Key keywords explained: FROM (base image), RUN (OS-level commands), CMD (application-level commands), COPY (host to image), ADD (internet to image), ENV (environment variables), EXPOSE (port exposure), WORKDIR (working directory)
Maintainer keyword is deprecated
Practical Exercise:

Created a Dockerfile with 5 lines to build an nginx image
Built image using: docker build -t .
Image optimization discussed: combining commands, using Alpine base images, using official images directly
Pushed images to Docker Hub after docker login authentication
Best Practices:

Keep Dockerfiles lightweight (typically 5-10 lines)
Avoid unnecessary packages
Use specific version tags
Prefer COPY over ADD for security and reliability
Golden image/hardening concepts for production use
Additional Concepts:

Multi-stage Dockerfiles for creating multiple containers
Dockerfile validation using lint tools
Difference between RUN (OS-level) and CMD (application-level) commands
Students practiced creating VMs, installing Docker, writing Dockerfiles, building images, and pushing to Docker Hub.

======================================================================================

Day 5:
docker run -it ubuntu
apt update
apt install python3
docker start containerid 
docker commit  <container ID>  yourname
docker save abhishekimagepython > sandeep.tar
1  sudo apt-get update &&  apt install docker.io -y
    2  docker run -it ubuntu
    3  docker images
    4  docker ps -a
    5  docker start 2d84148e8989
    6  docker ps
    7  docker images
    8  docker commit 2d84148e8989 abhishekimagepython
    9  docker images
   10  docker save abhishekimagepython > sandeep.tar
   11  ls
   12  docker ps
   13  docker inspect wonderful_cannon
   14  docker logs wonderful_cannon
   15  docker logs -f wonderful_cannon
   16  docker logs -follow wonderful_cannon
   17  docker stats
   18  docker logs -f wonderful_cannon > indra.log
   19  docker logs  wonderful_cannon > indra.log
   20  ls
   21  docker logs --follow wonderful_cannon
   
   ======================================================
   
ðŸ”¹ Docker Networking Demo: 2 Containers Communication
ðŸŽ¯ Goal

Create a custom Docker bridge network

Run 2 containers in the same network

Test container-to-container communication using container name (DNS)

ðŸ§± Step 1: Create a Custom Docker Network
docker network create batch42

Verify
docker network ls

ðŸ³ Step 2: Run Container-1 (Web Server)

Run nginx container:

docker run -d \
--name web1 \
--network batch42 \
nginx

docker run -d --name web1 --network batch42 nginx


ðŸ³ Step 3: Run Container-2 (Client / Tester)

Run a busybox container:

docker run -it \
--name client1 \
--network batch42 \
busybox sh

ðŸ” Step 4: Test Connectivity (IMPORTANT DEMO PART)

Inside client1 container:

âœ… Ping using container name (Docker DNS)
ping web1


ðŸ‘‰ You will see PING successful
ðŸ“Œ This proves:

Containers are connected

Docker provides built-in DNS

âœ… Test HTTP Connectivity
wget -qO- http://web1
==========================================================

Based on the meeting transcript, here are the Docker-related interview questions and answers that were discussed:

Interview Questions Covered:

Docker Operations Knowledge

The instructor asked students to rate their understanding of 10 day-to-day Docker operations (commands)
Students were expected to know Docker build, run, start, stop, restart commands
What is a Dockerfile?

Answer: A text file without any extension that holds instructions used to build a Docker image
Contains set of commands/instructions to assemble an image
Used with docker build command to create images
Can you create an image from a running container? (Reverse Engineering)

Answer: Yes, it is possible
Command: docker commit
This creates a new image from a container with installed applications
How to export Docker logs?

Answer: Use redirection operator
Command: docker logs > logfile.txt
Troubleshooting Commands:

docker inspect - to check container details, IP address, network info
docker logs - to view container logs
docker logs -f - to follow logs in real-time (f = follow)
docker stats - to check CPU and memory usage
docker top - to see running processes
How to save and transfer Docker images?

Answer: Convert image to tar file using docker save command
Command: docker save > filename.tar
To load back: docker load < filename.tar
Cleanup activities:

docker system df - to check disk space usage
docker system prune - to clean up unused containers, networks, images (requires approval in production)
docker image prune - to clean up only images
Important Note: The instructor emphasized not to run cleanup commands in production without manager/client approval.
================================

==========================================
Today's session covered Docker operations and troubleshooting, followed by an introduction to Kubernetes. Here's the summary:

Docker Operations Covered:

Day-to-day Docker operations and commands
Creating VMs and installing Docker
Working with Dockerfiles to build images
Container management (start, stop, restart)
Reverse engineering: Creating images from running containers using docker commit command
Saving Docker images as tar files using docker save command
Loading images from tar files using docker load command
Docker Troubleshooting:

docker inspect - to check detailed container information (IP address, gateway, network details)
docker logs - to view container logs (docker logs -f for real-time logs)
docker stats - to monitor CPU and memory usage
docker top - to view running processes
Exporting logs to files using redirection
Docker Networking:

Creating custom Docker networks using docker network create
Connecting containers to networks
Testing connectivity between containers in the same network using ping
Docker Cleanup:

docker system df - to check disk space usage and reclaimable space
docker system prune - to clean up stopped containers, unused networks and images
docker image prune - to clean up unused images
Important: Always take approval before running cleanup commands in production
Key Points:

Containers are lightweight, so some commands may need to be installed inside them
Manual management of many containers is difficult, leading to the need for Kubernetes
Kubernetes Introduction:

=============================================================================================

   

